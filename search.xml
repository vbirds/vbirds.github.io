<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[window下Qt编译Boost（使用MinGW）]]></title>
      <url>http://yoursite.com/2016/06/10/window%E4%B8%8BQt%E7%BC%96%E8%AF%91Boost%EF%BC%88%E4%BD%BF%E7%94%A8MinGW%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>我windows系统装的Qt版本是<code>Qt5.3.2(MinGW)</code>（就喜欢用原生的，不喜欢用MSVC的编译器）。最近写Boost的博客教程，给大家介绍下怎样编译Qt(MinGW)版本的用的Boost。</p>
<h3 id="1-添加系统环境变量"><a href="#1-添加系统环境变量" class="headerlink" title="1 添加系统环境变量"></a>1 添加系统环境变量</h3><p>这一步需要将Qt安装文件夹的<code>bin</code>目录添加到系统环境变量，我的Qt在D盘下，我们将<code>D:\Qt\5.3\mingw482_32\bin</code>这个文件路径添加到系统环境变量。再将Qt目录下的Tools文件夹下的mingw482_32的bin添加到系统环境变量<code>D:\Qt\Tools\mingw482_32\bin</code>。第一步就到这里，接下来是测试，看看是否添加环境变量成功。<br>打开<code>CMD</code>命令行窗口，输入<code>gcc --version</code>，如下显示说明添加成功：<br><a id="more"></a><br><img src="http://7xsc1o.com1.z0.glb.clouddn.com/Boostgcc-version.png" alt="enter description here"></p>
<h3 id="2-编译Boost构建工具"><a href="#2-编译Boost构建工具" class="headerlink" title="2 编译Boost构建工具"></a>2 编译Boost构建工具</h3><ol>
<li>打开<code>CMD</code>命令行窗口，进入Boost文件夹<code>D:\boost_1_57_0\tools\build\src\engine</code>下，执行命令 <code>bulid mingw</code>。执行后将在文件夹下生成<code>bin.ntx86</code>文件夹，文件夹里包含了两个Boost编译工具：<strong>bz.exe</strong> 和 <strong>bjam.exe</strong>。<br><img src="http://7xsc1o.com1.z0.glb.clouddn.com/Boost%E6%9E%84%E5%BB%BAbjiam.PNG" alt="enter description here"></li>
<li>我使用<strong>bjiam.exe</strong>这个编译工具，复制<strong>bjiam.ex</strong>e到Boost根目录下。<br><img src="http://7xsc1o.com1.z0.glb.clouddn.com/Boost%E5%A4%8D%E5%88%B6bjiam%E5%88%B0%E6%A0%B9%E7%9B%AE%E5%BD%95.PNG" alt="enter description here"></li>
</ol>
<h3 id="3-编译Boost"><a href="#3-编译Boost" class="headerlink" title="3 编译Boost"></a>3 编译Boost</h3><p>打开<code>CMD</code>命令行窗口进入Boost根目录，执行命令<code>bjam  --build-type=complete toolset=gcc stage</code>。程序开始编译Boost库了，时间比较长40分钟到小时不等，视机器的配置看。程序将在根目录下建立<code>stage</code>文件夹，编译好的boost库将存放在<code>stage/lib</code>文件夹下。如图：<br><img src="http://7xsc1o.com1.z0.glb.clouddn.com/Boostboost%E7%BC%96%E8%AF%91%E6%88%90%E5%8A%9Flib%E5%AD%98%E6%94%BE%E4%BD%8D%E7%BD%AE.PNG" alt="enter description here"></p>
<h3 id="4-boost库文件名意义说明"><a href="#4-boost库文件名意义说明" class="headerlink" title="4 boost库文件名意义说明"></a>4 boost库文件名意义说明</h3><p>我们看到编译好的库文件名称都是如下形式：<br><img src="http://7xsc1o.com1.z0.glb.clouddn.com/Boostboost%E5%BA%93%E6%96%87%E4%BB%B6%E5%90%8D.PNG" alt="enter description here"></p>
<p>其中参数意义如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>mt</td>
<td>threading=multi</td>
</tr>
<tr>
<td>s</td>
<td>runtime-link=static</td>
</tr>
<tr>
<td>d</td>
<td>variant=debug</td>
</tr>
<tr>
<td>.dll</td>
<td>link=shared</td>
</tr>
<tr>
<td>.dll.a</td>
<td>对应DLL的导入库文件</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[判断系统字节序（大端小端）]]></title>
      <url>http://yoursite.com/2016/06/09/%E5%88%A4%E6%96%AD%E7%B3%BB%E7%BB%9F%E5%AD%97%E8%8A%82%E5%BA%8F%EF%BC%88%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="字节序的定义"><a href="#字节序的定义" class="headerlink" title="字节序的定义"></a>字节序的定义</h3><p>所谓字节序，就是表示字节在内存中的存储序列。即字节在电脑中存放时的序列与输入（输出）时的序列是先到的在前还是后到的在前。</p>
<h3 id="字节序分类"><a href="#字节序分类" class="headerlink" title="字节序分类"></a>字节序分类</h3><p>字节在内存中的存储序列，有两种方式：</p>
<ol>
<li>将低序字节存储在起始地址，这称为<strong>小端</strong>（little-ending）</li>
<li>另一种是将高序字节存储在起始地址，这称为<strong>大端</strong>（big-ending)。大端字节序也称作<strong>网络字节序</strong>。</li>
</ol>
<a id="more"></a>
<p>其结构图如下：<br><img src="http://7xsc1o.com1.z0.glb.clouddn.com/uninx/linux%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E5%A4%A7%E5%B0%8F%E7%AB%AF%E5%AD%97%E8%8A%82%E5%BA%8F.PNG" alt="字节序结构图"></p>
<p>我们来写一个测试系统是大端字节序还是小端字节序列的程序，考虑用一个32为数（如：0x12345678），它由两个字节组成，对其取地址，将它转成（char<em>），在对此取首字节，如果首字节是<em>*0x78</em></em>，那么可以判断系统字节序是小端模式，否则是大端模式。</p>
<h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><p>程序如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestModel</span><span class="params">(<span class="keyword">char</span> *p)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d,%d,%d \n"</span>, p[<span class="number">0</span>], p[<span class="number">1</span>],p[<span class="number">2</span>], p[<span class="number">3</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p[<span class="number">0</span>] == <span class="number">0x78</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"当前系统是小端模式\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"当前系统是大端模式\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> data = <span class="number">0x12345678</span>;</span><br><span class="line">    <span class="keyword">char</span> *p = &amp;data;</span><br><span class="line">    </span><br><span class="line">    TestModel(p);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//x86 是小端模式   IBM 是大端模式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>一般来说x86平台的系统是小端模式，而IBM得系统平台一般是大端模式。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[STL学习之容器（1）list（双向链表）]]></title>
      <url>http://yoursite.com/2016/06/07/STL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8%EF%BC%881%EF%BC%89list%EF%BC%88%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p><strong>list</strong>是一个线性链表结构（双向链表），它的数据由若干个节点构成，每一个节点都包括一个信息块（即实际存储的数据）、一个前驱指针和一个后驱指针。它无需分配指定的内存大小且可以任意伸缩，这是因为它存储在非连续的内存空间中，并且由指针将有序的元素链接起来。<br><img src="http://7xsc1o.com1.z0.glb.clouddn.com/STLList.jpg" alt="enter description here"></p>
<h3 id="list特点"><a href="#list特点" class="headerlink" title="list特点"></a>list特点</h3><p>由于其结构的原因，<strong>list</strong>随机检索的性能非常的不好，因为它不像<strong>vector</strong>那样直接找到元素的地址，而是要从头一个一个的顺序查找，这样目标元素越靠后，它的检索时间就越长。检索时间与目标元素的位置成正比。<br><a id="more"></a></p>
<p>虽然随机检索的速度不够快，但是它可以迅速地在任何节点进行插入和删除操作。因为list 的每个节点保存着它在链表中的位置，插入或删除一个元素仅对最多三个元素有所影响，不像<strong>vector</strong>会对操作点之后的所有元素的存储地址都有所影响，这一点是<strong>vector</strong>不可比拟的。</p>
<p>list具有以下特点：</p>
<ol>
<li>不使用连续的内存空间这样可以随意地进行动态操作；</li>
<li>可以在内部任何位置快速地插入或删除，当然也可以在两端进行push和pop；</li>
<li>不能进行内部的随机访问，即不支持“[]” 操作符和 <code>vector.at()</code>；</li>
<li>Lists将元素按顺序储存在链表中，与向量(vectors)相比，它允许快速的插入和删除，但是随机访问却比较慢。</li>
</ol>
<h3 id="list的声明"><a href="#list的声明" class="headerlink" title="list的声明"></a>list的声明</h3><ol>
<li>声明一个空list<br><code>std::list&lt;int&gt; first;// empty list of ints</code></li>
<li>声明元素的个数和元素的值<br><code>std::list&lt;int&gt; second (5,100); // five ints with value 100</code></li>
<li>用迭代器给进行list的构造<br><code>std::list&lt;int&gt; third (second.begin(),second.end()); // iterating through second</code></li>
<li>引用另一个list赋值构造 这里进行了元素的拷贝<br><code>std::list&lt;int&gt; fourth (third); // a copy of third</code></li>
<li>也可以引用数组进行复制构造<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the iterator constructor can also be used to construct from arrays:</span></span><br><span class="line"><span class="keyword">int</span> myints[] = &#123;<span class="number">16</span>,<span class="number">2</span>,<span class="number">77</span>,<span class="number">29</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; fifth (myints, myints + <span class="keyword">sizeof</span>(myints) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="list的迭代器"><a href="#list的迭代器" class="headerlink" title="list的迭代器"></a>list的迭代器</h3><ol>
<li><p>begin 和 end 返回list首部和结尾的 iterator类型的迭代器，这里要说明一下，在<strong>c++11</strong>里已经将返回类型改为了 const_iterator</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//begin end</span></span><br><span class="line"><span class="keyword">int</span> myints[] = &#123;<span class="number">75</span>,<span class="number">23</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">13</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mylist (myints,myints+<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>rbegin 和 rend 和begin与end相反 rbegin返回指向结尾元素的迭代器，rend返回指向list开头的元素迭代器，在<strong>c++11</strong>里将原本的返回类型友<code>reverse_iterator</code>改为了<code>const_reverse_iterator</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rbegin rend</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist reverse contains:"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator it = mylist.rbegin(); it != mylist.rend(); ++it)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>cbegin 和 cend ，cbegin与cend是c++11新添加的方法，功能和 begin与end一样，只是返回类型不一样，它返回类型为：<code>const_iterator</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist use cbegin cend contains:"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = mylist.cbegin(); it != mylist.cend(); ++it)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>crbegin 和 crend。crbegin与crend也是c++11新添加的方法，功能和rbegin与rend一样，只是返回类型为：<code>const_reverse_iterator</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist use crbegin crend contains:"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_reverse_iterator it = mylist.crbegin(); it != mylist.crend(); ++it)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="list操作"><a href="#list操作" class="headerlink" title="list操作"></a>list操作</h3><h4 id="容量相关操作"><a href="#容量相关操作" class="headerlink" title="容量相关操作"></a>容量相关操作</h4><ol>
<li><p>empty 判断容器是否为空</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mylist;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span> <span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">//c++11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;++i) mylist.push_back(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!mylist.empty())</span><br><span class="line">&#123;</span><br><span class="line">   sum += mylist.front();</span><br><span class="line">   mylist.pop_front();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"total: "</span> &lt;&lt; sum &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>size 返回list元素的个数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"szie: "</span> &lt;&lt; mylist.size() &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>max_size 返回容器能够容纳的最大数量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max szie: "</span> &lt;&lt; mylist.max_size() &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="元素访问相关操作"><a href="#元素访问相关操作" class="headerlink" title="元素访问相关操作"></a>元素访问相关操作</h4><ol>
<li>front 和 back 返回list第一个元素和最后一个元素<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mylist;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;++i) mylist.push_back(i);</span><br><span class="line"><span class="comment">//front</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist.front() is now "</span> &lt;&lt; mylist.front() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="comment">//back</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist.back() is now "</span> &lt;&lt; mylist.back() &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h4><ol>
<li><p><strong>assign</strong> 分配新的内容列表容器，将取代其当前内容，并相应地修改其尺寸，assign有三种用法，第一是重新声明list的大小<code>first.assign (7,100);</code>，第二是用迭代器进行声明<code>second.assign (first.begin(),first.end());</code>,第三是用数组。下面的程序详细的展示了这三种用法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; first;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; second;</span><br><span class="line"></span><br><span class="line">first.assign (<span class="number">7</span>,<span class="number">100</span>);                      <span class="comment">// 7 ints with value 100</span></span><br><span class="line"></span><br><span class="line">second.assign (first.begin(),first.end()); <span class="comment">// a copy of first</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> myints[]=&#123;<span class="number">1776</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line">first.assign (myints,myints+<span class="number">3</span>);            <span class="comment">// assigning from array</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of first: "</span> &lt;&lt; <span class="keyword">int</span> (first.size()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of second: "</span> &lt;&lt; <span class="keyword">int</span> (second.size()) &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>push_front</strong> 与 <strong>push_back</strong> 在容器开始和结尾插入一个元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">second.push_front(<span class="number">22</span>);</span><br><span class="line">second.push_back(<span class="number">33</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"first element: "</span> &lt;&lt; second.front()&lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"last element: "</span> &lt;&lt; second.back() &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>pop_front</strong> 与 <strong>pop_back</strong> 删除第一个元素 和 最后一个元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">second.pop_front();</span><br><span class="line">second.pop_back();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"first element: "</span> &lt;&lt; second.front()&lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"last element: "</span> &lt;&lt; second.back() &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>insert</strong> 在指定位置插入元素，位置可以用迭代器指定，也可以用迭代器将指定范围的元素插入到list中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">it = first.begin();</span><br><span class="line">++it;                       <span class="comment">//it points now to num 7</span></span><br><span class="line">first.insert(it, <span class="number">10</span>);       <span class="comment">// 1776 10 7 4</span></span><br><span class="line"><span class="comment">//"it" still points to number 7</span></span><br><span class="line">first.insert(it, <span class="number">2</span>, <span class="number">20</span>);    <span class="comment">// 1776 20 20 10 7 4</span></span><br><span class="line"></span><br><span class="line">--it;</span><br><span class="line"><span class="comment">//now "it" points to number 20</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (<span class="number">2</span>,<span class="number">30</span>);</span><br><span class="line">first.insert(it, myvector.begin(), myvector.end());</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist contains:"</span>;</span><br><span class="line">print(first);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>erast</strong> 删除指定位置的元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it1,it2;</span><br><span class="line">it1 = first.begin();</span><br><span class="line">it2 = first.end();</span><br><span class="line">it1 = first.erase(it1);</span><br><span class="line">first.erase (it1,it2);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist contains:"</span>;</span><br><span class="line">print(first);     <span class="comment">// empty</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>clear</strong> 从容器中移除所有元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">second.clear();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>emplace_fron</strong>t 与 <strong>emplace_back</strong> 在容器的开头和结尾插入一个新元素。这两个操作是<strong>c++11</strong>里的方法，这里讲一讲和<strong>push_front</strong> 和 <strong>push_back</strong> 的不同，<strong>emplace_front</strong> 与 <strong>emplace_back</strong>是构造参数里的元素，然后将它插入，而<strong>push_front</strong> 和 <strong>push_back</strong> 是将参数拷贝后插入<strong>list</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">first.emplace_front(<span class="number">10</span>);</span><br><span class="line">first.emplace_front(<span class="number">20</span>);  <span class="comment">// 20 10</span></span><br><span class="line">first.emplace_back(<span class="number">30</span>);</span><br><span class="line">first.emplace_back(<span class="number">40</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h4><ol>
<li><strong>splice</strong> 移动另一个容器的元素到现容器中。<strong>splice</strong>的定义如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function">entire <span class="title">list</span> <span class="params">(<span class="number">1</span>)</span>	<span class="keyword">void</span> <span class="title">splice</span> <span class="params">(iterator position, <span class="built_in">list</span>&amp; x)</span></span>;</span><br><span class="line"><span class="function">single <span class="title">element</span> <span class="params">(<span class="number">2</span>)</span>	<span class="keyword">void</span> <span class="title">splice</span> <span class="params">(iterator position, <span class="built_in">list</span>&amp; x, iterator i)</span></span>;</span><br><span class="line"> <span class="function">element <span class="title">range</span> <span class="params">(<span class="number">3</span>)</span>	<span class="keyword">void</span> <span class="title">splice</span> <span class="params">(iterator position, <span class="built_in">list</span>&amp; x, iterator first, iterator last)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mylist1, mylist2;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set some initial values:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">4</span>; ++i)</span><br><span class="line">   mylist1.push_back(i);      <span class="comment">// mylist1: 1 2 3 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; ++i)</span><br><span class="line">   mylist2.push_back(i*<span class="number">10</span>);   <span class="comment">// mylist2: 10 20 30</span></span><br><span class="line"></span><br><span class="line">it = mylist1.begin();</span><br><span class="line">++it;                         <span class="comment">// points to 2</span></span><br><span class="line"></span><br><span class="line">mylist1.splice (it, mylist2); <span class="comment">// mylist1: 1 10 20 30 2 3 4</span></span><br><span class="line">                              <span class="comment">// mylist2 (empty)</span></span><br><span class="line">                              <span class="comment">// "it" still points to 2 (the 5th element)</span></span><br><span class="line"></span><br><span class="line">mylist2.splice (mylist2.begin(),mylist1, it);</span><br><span class="line">                              <span class="comment">// mylist1: 1 10 20 30 3 4</span></span><br><span class="line">                              <span class="comment">// mylist2: 2</span></span><br><span class="line">                              <span class="comment">// "it" is now invalid.</span></span><br><span class="line">it = mylist1.begin();</span><br><span class="line"><span class="built_in">std</span>::advance(it,<span class="number">3</span>);           <span class="comment">// "it" points now to 30</span></span><br><span class="line"></span><br><span class="line">mylist1.splice ( mylist1.begin(), mylist1, it, mylist1.end());</span><br><span class="line">                              <span class="comment">// mylist1: 30 3 4 1 10 20</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist1 contains:"</span>;</span><br><span class="line"><span class="keyword">for</span> (it=mylist1.begin(); it!=mylist1.end(); ++it)</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist2 contains:"</span>;</span><br><span class="line"><span class="keyword">for</span> (it=mylist2.begin(); it!=mylist2.end(); ++it)</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>merge</strong> 合并容器。定义如下：待合并的list被插入当前的list中，还可以设置条件函数，满足条件函数的元素才能被合并到当前list中。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)	<span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(<span class="built_in">list</span>&amp; x)</span></span>;</span><br><span class="line">(<span class="number">2</span>)	<span class="keyword">template</span> &lt;<span class="keyword">class</span> Compare&gt;</span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">merge</span> <span class="params">(<span class="built_in">list</span>&amp; x, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mycomparison</span> <span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ( <span class="keyword">int</span>(first)&gt;<span class="keyword">int</span>(second) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mylist1.merge(mylist2);</span><br><span class="line">print(mylist1);</span><br><span class="line"></span><br><span class="line">mylist2.push_back(<span class="number">98</span>);</span><br><span class="line">mylist1.merge(mylist2, mycomparison);  <span class="comment">// 这里的函数不能用模板</span></span><br><span class="line">print(mylist1);</span><br></pre></td></tr></table></figure>
<ol>
<li><p><strong>sort</strong> 排序，sort方法还可以指定比较大小的函数，默认情况是按照从小到大排序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mycomparison</span> <span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ( <span class="keyword">int</span>(first)&gt;<span class="keyword">int</span>(second) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mylist1.sort();  <span class="comment">//默认从小到大排序</span></span><br><span class="line">print(mylist1);</span><br><span class="line">mylist1.sort(mycomparison); <span class="comment">//按mycomparison进行比较</span></span><br><span class="line">print(mylist1);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>unique</strong> 去除重复的元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mylist1.unique();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="完整源码"><a href="#完整源码" class="headerlink" title="完整源码"></a>完整源码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">list</span>&lt;T&gt;&amp; c)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">' '</span> &lt;&lt; x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test_Constructor</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//声明一个空List</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; first;                                <span class="comment">// empty list of ints</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; second (<span class="number">5</span>,<span class="number">100</span>);                       <span class="comment">// five ints with value 100</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; third (second.begin(),second.end());  <span class="comment">// iterating through second</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; fourth (third);                       <span class="comment">// a copy of third</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// the iterator constructor can also be used to construct from arrays:</span></span><br><span class="line">    <span class="keyword">int</span> myints[] = &#123;<span class="number">16</span>,<span class="number">2</span>,<span class="number">77</span>,<span class="number">29</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; fifth (myints, myints + <span class="keyword">sizeof</span>(myints) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The contents of fifth are: "</span>;</span><br><span class="line">    print(fifth);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test_Iterators</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//begin end</span></span><br><span class="line">    <span class="keyword">int</span> myints[] = &#123;<span class="number">75</span>,<span class="number">23</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">13</span>&#125;;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mylist (myints,myints+<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist contains:"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it=mylist.begin(); it != mylist.end(); ++it)</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//rbegin rend</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist reverse contains:"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator it = mylist.rbegin(); it != mylist.rend(); ++it)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*-------c++11--------*/</span></span><br><span class="line">    <span class="comment">//cbegin cend  返回const类型的interator (const_iterator)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist use cbegin cend contains:"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = mylist.cbegin(); it != mylist.cend(); ++it)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//crbegin crend 返回const类型的reverse_iterator（const_reverse_iterator)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist use crbegin crend contains:"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_reverse_iterator it = mylist.crbegin(); it != mylist.crend(); ++it)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test_Capacity</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//empty</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mylist;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span> <span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">//c++11</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;++i) mylist.push_back(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!mylist.empty())</span><br><span class="line">    &#123;</span><br><span class="line">       sum += mylist.front();</span><br><span class="line">       mylist.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"total: "</span> &lt;&lt; sum &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//size 返回list大小 元素个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;++i) mylist.push_back(i);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"szie: "</span> &lt;&lt; mylist.size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//max_size 返回容器能够容纳的最大数量</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max szie: "</span> &lt;&lt; mylist.max_size() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test_Element_Access</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mylist;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;++i) mylist.push_back(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//front</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist.front() is now "</span> &lt;&lt; mylist.front() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="comment">//back</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist.back() is now "</span> &lt;&lt; mylist.back() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test_Modifiers</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//assign 分配新的内容列表容器，将取代其当前内容，并相应地修改其尺寸。</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; first;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; second;</span><br><span class="line"></span><br><span class="line">    first.assign (<span class="number">7</span>,<span class="number">100</span>);                      <span class="comment">// 7 ints with value 100</span></span><br><span class="line"></span><br><span class="line">    second.assign (first.begin(),first.end()); <span class="comment">// a copy of first</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> myints[]=&#123;<span class="number">1776</span>,<span class="number">7</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    first.assign (myints,myints+<span class="number">3</span>);            <span class="comment">// assigning from array</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of first: "</span> &lt;&lt; <span class="keyword">int</span> (first.size()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Size of second: "</span> &lt;&lt; <span class="keyword">int</span> (second.size()) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// push_front 与 push_back 在容器开始和结尾插入一个元素</span></span><br><span class="line">    second.push_front(<span class="number">22</span>);</span><br><span class="line">    second.push_back(<span class="number">33</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"first element: "</span> &lt;&lt; second.front()&lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"last element: "</span> &lt;&lt; second.back() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pop_front pop_back 删除第一个元素 和最后一个元素</span></span><br><span class="line">    second.pop_front();</span><br><span class="line">    second.pop_back();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"first element: "</span> &lt;&lt; second.front()&lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"last element: "</span> &lt;&lt; second.back() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//insert</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">    it = first.begin();</span><br><span class="line">    ++it;                       <span class="comment">//it points now to num 7</span></span><br><span class="line">    first.insert(it, <span class="number">10</span>);       <span class="comment">// 1776 10 7 4</span></span><br><span class="line">    <span class="comment">//"it" still points to number 7</span></span><br><span class="line">    first.insert(it, <span class="number">2</span>, <span class="number">20</span>);    <span class="comment">// 1776 20 20 10 7 4</span></span><br><span class="line"></span><br><span class="line">    --it;</span><br><span class="line">    <span class="comment">//now "it" points to number 20</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (<span class="number">2</span>,<span class="number">30</span>);</span><br><span class="line">    first.insert(it, myvector.begin(), myvector.end());</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist contains:"</span>;</span><br><span class="line">    print(first);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//erase</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it1,it2;</span><br><span class="line">    it1 = first.begin();</span><br><span class="line">    it2 = first.end();</span><br><span class="line">    it1 = first.erase(it1);</span><br><span class="line">    first.erase (it1,it2);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist contains:"</span>;</span><br><span class="line">    print(first);     <span class="comment">// empty</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//clear  从容器中移除所有元素</span></span><br><span class="line">    second.clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*--------------c++11----------------*/</span></span><br><span class="line">    <span class="comment">//emplace_front emplace_back 在容器的开头和结尾插入一个新元素</span></span><br><span class="line">    first.emplace_front(<span class="number">10</span>);</span><br><span class="line">    first.emplace_front(<span class="number">20</span>);  <span class="comment">// 20 10</span></span><br><span class="line">    first.emplace_back(<span class="number">30</span>);</span><br><span class="line">    first.emplace_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compare only integral part:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mycomparison</span> <span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ( <span class="keyword">int</span>(first)&gt;<span class="keyword">int</span>(second) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test_Operations</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//splice  //移动另一个容器的元素到现容器中</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; mylist1, mylist2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set some initial values:</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">4</span>; ++i)</span><br><span class="line">       mylist1.push_back(i);      <span class="comment">// mylist1: 1 2 3 4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; ++i)</span><br><span class="line">       mylist2.push_back(i*<span class="number">10</span>);   <span class="comment">// mylist2: 10 20 30</span></span><br><span class="line"></span><br><span class="line">    it = mylist1.begin();</span><br><span class="line">    ++it;                         <span class="comment">// points to 2</span></span><br><span class="line"></span><br><span class="line">    mylist1.splice (it, mylist2); <span class="comment">// mylist1: 1 10 20 30 2 3 4</span></span><br><span class="line">                                  <span class="comment">// mylist2 (empty)</span></span><br><span class="line">                                  <span class="comment">// "it" still points to 2 (the 5th element)</span></span><br><span class="line"></span><br><span class="line">    mylist2.splice (mylist2.begin(),mylist1, it);</span><br><span class="line">                                  <span class="comment">// mylist1: 1 10 20 30 3 4</span></span><br><span class="line">                                  <span class="comment">// mylist2: 2</span></span><br><span class="line">                                  <span class="comment">// "it" is now invalid.</span></span><br><span class="line">    it = mylist1.begin();</span><br><span class="line">    <span class="built_in">std</span>::advance(it,<span class="number">3</span>);           <span class="comment">// "it" points now to 30</span></span><br><span class="line"></span><br><span class="line">    mylist1.splice ( mylist1.begin(), mylist1, it, mylist1.end());</span><br><span class="line">                                  <span class="comment">// mylist1: 30 3 4 1 10 20</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist1 contains:"</span>;</span><br><span class="line">    <span class="keyword">for</span> (it=mylist1.begin(); it!=mylist1.end(); ++it)</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mylist2 contains:"</span>;</span><br><span class="line">    <span class="keyword">for</span> (it=mylist2.begin(); it!=mylist2.end(); ++it)</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//merge 合并容器</span></span><br><span class="line">    mylist1.merge(mylist2);</span><br><span class="line">    print(mylist1);</span><br><span class="line"></span><br><span class="line">    mylist2.push_back(<span class="number">98</span>);</span><br><span class="line">    mylist1.merge(mylist2, mycomparison);  <span class="comment">// 这里的函数不能用模板</span></span><br><span class="line">    print(mylist1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sort 排序</span></span><br><span class="line">    mylist1.sort();  <span class="comment">//默认从小到大排序</span></span><br><span class="line">    print(mylist1);</span><br><span class="line">    mylist1.sort(mycomparison); <span class="comment">//按mycomparison进行比较</span></span><br><span class="line">    print(mylist1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//unique 去除重复的元素</span></span><br><span class="line">    mylist1.unique();</span><br><span class="line">    print(mylist1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//声明</span></span><br><span class="line">    Test_Constructor();</span><br><span class="line">    <span class="comment">//迭代器</span></span><br><span class="line">    Test_Iterators();</span><br><span class="line">    <span class="comment">//容量相关操作</span></span><br><span class="line">    Test_Capacity();</span><br><span class="line">    <span class="comment">//元素访问相关操作</span></span><br><span class="line">    Test_Element_Access();</span><br><span class="line">    <span class="comment">//修改操作</span></span><br><span class="line">    Test_Modifiers();</span><br><span class="line">    <span class="comment">//Operations</span></span><br><span class="line">    Test_Operations();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="http://www.cplusplus.com/" target="_blank" rel="external">C++ Reference</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UNIX环境高级编程（二）进程控制（1）]]></title>
      <url>http://yoursite.com/2016/06/06/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%881%EF%BC%89/</url>
      <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本节介绍U N I X的进程控制，包括进程的概念，创建新进程、进程标识、孤儿进程和僵尸进程，以及怎样避免僵尸和孤儿进程的方法。</p>
<h3 id="理解程序和进程"><a href="#理解程序和进程" class="headerlink" title="理解程序和进程"></a>理解程序和进程</h3><p>先来理解下什么是<strong>程序</strong>。我们编写的代码，都可以称为程序</p>
<blockquote>
<p>程序是完成特定任务的一系列指令集合</p>
</blockquote>
<p>那么什么是进程呢？</p>
<ol>
<li>从用户的角度来看进程是程序的一次执行过程；</li>
<li>从操作系统的核心来看，进程是操作系统分配的内存、CPU时间片等资源的基本单位；</li>
<li>进程是资源分配的最小单位；</li>
<li>每一个进程都有自己独立的地址空间与执行状态。</li>
</ol>
<a id="more"></a>
<p>像Unix/Linux这样的多任务操作系统能够让许多程序同时运行，每一个运行着的程序就构成了一个进程。</p>
<h3 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h3><p>每个进程都有一个非负整型的唯一进程ID。因为进程ID标识符总是唯一的，常将其用做其他标识符的一部分以保证其唯一性。在Unix/Linux中获取进程标识有如下函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> getpid(<span class="keyword">void</span>);  返回：调用进程的进程<span class="function">I D</span><br><span class="line">pid_t <span class="title">getppid</span><span class="params">(<span class="keyword">void</span>)</span></span>; 返回：调用进程的父进程<span class="function">I D</span><br><span class="line">uid_t <span class="title">getuid</span><span class="params">(<span class="keyword">void</span>)</span></span>;  返回：调用进程的实际用户<span class="function">I D</span><br><span class="line">uid_t <span class="title">geteuid</span><span class="params">(<span class="keyword">void</span>)</span></span>; 返回：调用进程的有效用户<span class="function">I D</span><br><span class="line">gid_t <span class="title">getgid</span><span class="params">(<span class="keyword">void</span>)</span></span>;  返回：调用进程的实际组<span class="function">I D</span><br><span class="line">gid_t <span class="title">getegid</span><span class="params">(<span class="keyword">void</span>)</span></span>; 返回：调用进程的有效组I D</span><br></pre></td></tr></table></figure></p>
<h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><p>在Unix/Linux中进程的创建有<code>fork</code>函数和<code>vfork</code>函数。</p>
<h4 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h4><p>fork的定义如下: 执行成功时返回子进程的ID，错误返回-1。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure></p>
<p>由fork创建的新进程被称为子进程(childprocess)。该函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是0，而父进程的返回值则是新子进程的进程ID。<br>使用fork函数得到的子进程从父进程的继承了整个进程的地址空间，包括：进程上下文、进程堆栈、内存信息、打开的文件描述符、信号控制设置、进程优先级、进程组号、当前工作目录、根目录、资源限制、控制终端等。这里要理解两个问题：</p>
<ol>
<li>怎么样理解一次调用2次返回?<br>两次返回，是在各自的进程空间中返回的。</li>
<li>怎么样理解，fork返回值大于零的是父进程，为什么这样设计？<br>一个进程只会有一个父进程，所以子进程总是可以调用getppid以获得其父进程的进程ID(进程ID0总是由交换进程使用,所以一个子进程的进程I D不可能为0 )。</li>
</ol>
<h4 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h4><p>现在很多的实现并不做一个父进程数据段和堆的完全拷贝，因为在fork之后经常跟随着exec。作为替代，使用了在写时复制(Copy-On-Write, COW)的技术。这些区域由父、子进程共享，而且内核将它们的存取许可权改变为只读的。如果有进程试图修改这些区域，则内核为有<br>关部分，典型的是虚存系统中的“页”，做一个拷贝。</p>
<p>如下程序展示了子进程获得的变量是父进程的拷贝：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span> )</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    signal(SIGCHLD, SIG_IGN);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"befor fork pid:%d \n"</span>, getpid());</span><br><span class="line">    <span class="keyword">int</span> abc = <span class="number">10</span>;</span><br><span class="line">    pid = fork(); <span class="comment">//errno</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)	</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">//printf("pid &lt; 0 err.\n");</span></span><br><span class="line">    	perror(<span class="string">"tile"</span>);</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	abc ++;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"parent: pid:%d \n"</span>, getpid());</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"abc: %d \n"</span>, abc);</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"pid: %d"</span>, pid);</span><br><span class="line">    	sleep(<span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	abc ++;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"child: %d, parent: %d \n"</span>, getpid(), getppid());</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"abc: %d \n"</span>, abc);</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//sleep(100);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork after....\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="vfork函数"><a href="#vfork函数" class="headerlink" title="vfork函数"></a>vfork函数</h4><p>在fork还没实现从copy on write 之前。Unix设计者很关心fork之后立刻执行exec所造成的地址空间浪费，所以引入了vfork系统调用。<br>即使fork实现了copy on write，效率也没有vfork高，但是我们不推荐使用vfork，因为几乎每一个vfork的实现，都或多或少存在一定的问题。<br>而且vfork有个限制，子进程必须立刻执行_exit或者exec函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vfork实例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span> )</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span>		ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> *<span class="keyword">const</span> argv[] = &#123;<span class="string">"ls"</span>, <span class="string">"-l"</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"befor fork pid:%d \n"</span>, getpid());</span><br><span class="line"></span><br><span class="line">pid = vfork(); <span class="comment">//errno</span></span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">-1</span>)	</span><br><span class="line">&#123;</span><br><span class="line">    	<span class="comment">//printf("pid &lt; 0 err.\n");</span></span><br><span class="line">    	perror(<span class="string">"tile"</span>);</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"parent: pid:%d \n"</span>, getpid());</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"pid: %d\n"</span>, pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"child: %d, parent: %d \n"</span>, getpid(), getppid());</span><br><span class="line">    </span><br><span class="line">    	ret = execve(<span class="string">"/bin/ls"</span>, argv, <span class="literal">NULL</span>);</span><br><span class="line">    	<span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    	&#123;</span><br><span class="line">    		perror(<span class="string">"execve"</span>);		</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"execve 测试有没有执行\n"</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork after....\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="孤儿进程和僵尸进程"><a href="#孤儿进程和僵尸进程" class="headerlink" title="孤儿进程和僵尸进程"></a>孤儿进程和僵尸进程</h3><p>在fork之后处理文件描述符有两种常见的情况：</p>
<ol>
<li>如果父进程先退出，子进程还没退出那么子进程的父进程将变为init进程，子进程托孤给init进程。（注：任何一个进程都必须有父进程）</li>
<li>如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵进程。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//托孤  父进程先死</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span> )</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    signal(SIGCHLD, SIG_IGN);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"befor fork pid:%d \n"</span>, getpid());</span><br><span class="line">    <span class="keyword">int</span> abc = <span class="number">10</span>;</span><br><span class="line">    pid = fork(); <span class="comment">//errno</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)	</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="comment">//printf("pid &lt; 0 err.\n");</span></span><br><span class="line">    	perror(<span class="string">"tile"</span>);</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	abc ++;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"parent: pid:%d \n"</span>, getpid());</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"abc: %d \n"</span>, abc);</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"pid: %d"</span>, pid);</span><br><span class="line">    	<span class="comment">//sleep(20);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	sleep(<span class="number">30</span>);</span><br><span class="line">    	abc ++;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"child: %d, parent: %d \n"</span>, getpid(), getppid());</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"abc: %d \n"</span>, abc);	</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork after....\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//僵尸进程  子进程先死</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span> )</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"befor fork pid:%d \n"</span>, getpid());</span><br><span class="line">    <span class="keyword">int</span> abc = <span class="number">10</span>;</span><br><span class="line">    pid = fork(); <span class="comment">//errno</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)	</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf("pid &lt; 0 err.\n");</span></span><br><span class="line">        perror(<span class="string">"tile"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">20</span>);</span><br><span class="line">        abc ++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent: pid:%d \n"</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"abc: %d \n"</span>, abc);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pid: %d"</span>, pid);</span><br><span class="line">        <span class="comment">//sleep(20);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//sleep(30);</span></span><br><span class="line">        abc ++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child: %d, parent: %d \n"</span>, getpid(), getppid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"abc: %d \n"</span>, abc);	</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork after....\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解决僵尸进程"><a href="#解决僵尸进程" class="headerlink" title="解决僵尸进程"></a>解决僵尸进程</h4><p>解决僵尸进程的方法就是告知内核让内核清理，只需用注册信号就可：<br><code>signal(SIGCHLD, SIG_IGN)</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解决僵尸进程  1.让内核清理（信号量 signal(SIGCHLD, SIG_IGN);）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span> )</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    signal(SIGCHLD, SIG_IGN);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"befor fork pid:%d \n"</span>, getpid());</span><br><span class="line">    <span class="keyword">int</span> abc = <span class="number">10</span>;</span><br><span class="line">    pid = fork(); <span class="comment">//errno</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)	</span><br><span class="line">    &#123;</span><br><span class="line">    	perror(<span class="string">"tile"</span>);</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	sleep(<span class="number">20</span>);</span><br><span class="line">    	abc ++;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"parent: pid:%d \n"</span>, getpid());</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"abc: %d \n"</span>, abc);</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"pid: %d"</span>, pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	abc ++;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"child: %d, parent: %d \n"</span>, getpid(), getppid());</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"abc: %d \n"</span>, abc);	</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork after....\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="exec函数族替换进程印象"><a href="#exec函数族替换进程印象" class="headerlink" title="exec函数族替换进程印象"></a>exec函数族替换进程印象</h3><p>在进程的创建上Unix采用了一个独特的方法，它将进程创建与加载一个新进程映象分离。这样的好处是有更多的余地对两种操作进行管理。<br>当我们创建了一个进程之后，通常将子进程替换成新的进程映象，这可以用exec系列的函数来进行。当然，exec系列的函数也可以将当前进程替换掉。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg,</span><br><span class="line">          ..., <span class="keyword">char</span> * <span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvpe</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[],</span><br><span class="line">           <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//演示程序被完全替换</span></span><br><span class="line">    <span class="comment">//替换以后，pid不会发生变化</span></span><br><span class="line">    <span class="comment">//注意 printf后的\n不能忘记，不然main函数打印不出来</span></span><br><span class="line">    <span class="built_in">printf</span>(“main getpid: %d\n”, getpid());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//execlp(“ls”, “ls”, “-lt”,  NULL);</span></span><br><span class="line">    <span class="keyword">int</span> ret = execlp(“./testpid2”, <span class="literal">NULL</span>, <span class="literal">NULL</span>); </span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	perror(“ERR: “);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(“fork after….\n”);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="wait和waitpid函数"><a href="#wait和waitpid函数" class="headerlink" title="wait和waitpid函数"></a>wait和waitpid函数</h3><blockquote>
<p>当一个进程正常或异常终止时，内核就向其父进程发送SIGCHLD信号。因为子进程终止是个异步事件(这可以在父进程运行的任何时候发生)，所以这种信号也是内核向父进程发的异步通知。</p>
</blockquote>
<p>wait和waitpid函数用来让进程等待某一进程（一般是子进程或父进程），当调用wait和waitpid函数进程会进入阻塞态，知道此进程结束，其函数定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *status);</span><br><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *status, <span class="keyword">int</span> options);</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>pid == -1</td>
<td>等待任一子进程。于是在这一功能方面w a i t p i d与w a i t等效。</td>
</tr>
<tr>
<td>pid &gt; 0</td>
<td>等待其进程I D与p i d相等的子进程。</td>
</tr>
<tr>
<td>pid == 0</td>
<td>等待其组I D等于调用进程的组I D的任一子进程。</td>
</tr>
<tr>
<td>pid &lt; -1</td>
<td>等待其组I D等于p i d的绝对值的任一子进程。</td>
</tr>
</tbody>
</table>
<h4 id="Wait和waitpid区别和联系"><a href="#Wait和waitpid区别和联系" class="headerlink" title="Wait和waitpid区别和联系"></a>Wait和waitpid区别和联系</h4><ol>
<li>在一个子进程终止前， wait 使其调用者阻塞，而waitpid 有一选择项，可使调用者不阻塞。</li>
<li>waitpid并不等待第一个终止的子进程—它有若干个选择项，可以控制它所等待的特定进程。</li>
<li>实际上wait函数是waitpid函数的一个特例。</li>
</ol>
<h3 id="system-C库函数"><a href="#system-C库函数" class="headerlink" title="system C库函数"></a>system C库函数</h3><p><code>system()</code>函数调用“<code>/bin/sh -c command</code>”执行特定的命令，阻塞当前进程直到command命令执行完毕。<br>原型：<br>    <code>int system(const char *command);</code></p>
<p>我们自己来写一个System调用函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动动手写system命令</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">NULL</span>)</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">    	status = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    	execl(<span class="string">"/bin/sh"</span>, <span class="string">"sh"</span>, <span class="string">"-c"</span>, command, <span class="literal">NULL</span>);</span><br><span class="line">    	<span class="built_in">exit</span>(<span class="number">127</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">while</span> (waitpid(pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">    			<span class="keyword">continue</span>;</span><br><span class="line">    		</span><br><span class="line">    		status = <span class="number">-1</span>;</span><br><span class="line">    		<span class="keyword">break</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[STL学习之容器（1）vector（包含c++11）]]></title>
      <url>http://yoursite.com/2016/06/05/STL%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8%EF%BC%881%EF%BC%89vector%EF%BC%88%E5%8C%85%E5%90%ABc++11%EF%BC%89/</url>
      <content type="html"><![CDATA[<p><code>vector</code>是一个线性顺序结构。相当于数组，但其大小可以不预先指定，并且自动扩展。它可以像数组一样被操作，由于它的特性我们完全可以将<code>vector</code>看作动态数组。</p>
<h3 id="vector创建"><a href="#vector创建" class="headerlink" title="vector创建"></a>vector创建</h3><p>在创建一个vector后，它会自动在内存中分配一块连续的内存空间进行数据存储，初始的空间大小可以预先指定也可以由vector默认指定，这个大小即<code>capacity()</code>函数的返回值。<br><code>vector</code>的创建包括四种方式（c++98):<br><a id="more"></a></p>
<ol>
<li><p>直接声明一个空vector</p>
<figure class="highlight plain"><figcaption><span>first;```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2. 声明元素个数和元素值</span><br><span class="line">```std::vector&lt;int&gt; second (4,100);```声明了4个值为100的vector。</span><br><span class="line">3. 用迭代器实现赋值构造</span><br><span class="line">```std::vector&lt;int&gt; third (second.begin(),second.end());</span><br></pre></td></tr></table></figure>
</li>
<li><p>引用另一个vector作为构造参数</p>
<figure class="highlight plain"><figcaption><span>fourth (third);```拷贝了third的元素。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">c++11 里增加了引用list作为构造参数的支持</span><br><span class="line">```cpp</span><br><span class="line">std::list&lt;int&gt; first(2,3);</span><br><span class="line">std::vector&lt;int&gt; second(first);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="vector里的迭代器"><a href="#vector里的迭代器" class="headerlink" title="vector里的迭代器"></a>vector里的迭代器</h3><p>vector的迭代器有两种：<code>iterator</code> <code>reverse_iterator</code>。c++11又增加了两种支持 <code>const_iterator</code> 和 <code>const_reverse_iterator</code>。类型为const的迭代器不允许对指向的数据进行修改。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>begin</td>
<td>返回指向vector首部的iterator</td>
</tr>
<tr>
<td>end</td>
<td>返回指向vector结尾的iterator</td>
</tr>
<tr>
<td>rbegin</td>
<td>返回一个(reverse_iterator)反向迭代器指向最后一个元素</td>
</tr>
<tr>
<td>rend</td>
<td>返回一个(reverse_iterator)反向迭代器指向第一个元素（被认为是反向的结束）</td>
</tr>
<tr>
<td>cbegin(c++11)</td>
<td>返回指向vector首部const_iterator</td>
</tr>
<tr>
<td>cend(c++11)</td>
<td>返回指向vector结尾的const_iterator</td>
</tr>
<tr>
<td>crbegin(c++11)</td>
<td>返回一个(const_reverse_iterator)反向迭代器指向第一个元素</td>
</tr>
<tr>
<td>crend(c++11)</td>
<td>返回一个(const_reverse_iterator)反向迭代器指向最后一个元素</td>
</tr>
</tbody>
</table>
<h3 id="vector操作"><a href="#vector操作" class="headerlink" title="vector操作"></a>vector操作</h3><p>vector的操作分为 <strong>容量相关</strong>、<strong>元素访问</strong>、<strong>元素修改</strong></p>
<h4 id="容量相关"><a href="#容量相关" class="headerlink" title="容量相关"></a>容量相关</h4><ol>
<li>size：返回容器元素个数<br><code>printf(&quot;vector size: %d\n&quot;, v2.size());</code></li>
<li>max_size：返回vector能装的最大元素个数<br><code>printf(&quot;vector max_size: %d\n&quot;, v2.max_size());</code></li>
<li>capacity：返回vector当前的容量<br><code>printf(&quot;vector capacity: %d\n&quot;, v2.capacity());</code></li>
<li>empty：判断元素是否 为空<br><code>printf(&quot;vector is empty? : %s\n&quot;, v4.empty()? &quot;yes&quot; : &quot;no&quot;);</code></li>
<li><p>reserve：修改当前vector的容量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bar;</span><br><span class="line">sz = bar.capacity();</span><br><span class="line">bar.reserve(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>resize(size_type  n)：删除或添加元素以满足vector当前的容量。如果n小于当前容量,则减少到第n个元素,删除那些超出的部分。如果n大于当前容器大小,末尾的内容由插入了尽可能多的元素需要达到的大小n。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myvector.resize(<span class="number">5</span>);</span><br><span class="line">myvector.resize(<span class="number">8</span>,<span class="number">100</span>);</span><br><span class="line">myvector.resize(<span class="number">12</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h4><ol>
<li>operator[]：可像数组一样用访问下标元素值<br><code>printf(&quot;vector[2]: %d\n&quot;, v5[2]);</code></li>
<li>at(size_type n)：返回位置n元素的引用<br><code>printf(&quot;vector at(2): %d\n&quot;, v5.at(2));</code></li>
<li>front：返回第一个元素的引用<br><code>printf(&quot;vector front: %d\n&quot;, v5.front());</code></li>
<li>back：返回最后一个元素的引用<br><code>printf(&quot;vector back: %d\n&quot;, v5.back());</code></li>
<li><strong>data(c++11)</strong>：直接返回一个指针指向的内存数组向量存储的所有元素<br><code>printf(&quot;vector data(1): %d\n&quot;, (v5.data())[1]);</code></li>
</ol>
<h4 id="元素修改"><a href="#元素修改" class="headerlink" title="元素修改"></a>元素修改</h4><ol>
<li>assign：assign有两种重载 <code>void assign (InputIterator first, InputIterator last);</code> 和 <code>void assign (size_type n, const value_type&amp; val);</code>第一种用迭代器为vector添加值，第二种声明添加元素的个数和元素的值。<br><code>v5.assign(5, 11); //添加5个值为11的元素到vector里</code></li>
<li>push_back(const value_type&amp; val) :添加一个新元素到vector末尾。</li>
<li>pop_back：<code>删除最后一个元素</code><br><code>v5.pop_back();</code></li>
<li>erase：同样有两种重载 <code>erase (iterator position);</code> 和 <code>erase (iterator first, iterator last);</code> c++11对这两个重载重新定义了<code>erase (const_iterator position);</code>和 <code>erase (const_iterator first, const_iterator last);</code><br><code>v5.erase(v5.begin(), v5.end()); //清除从 begin()到end()的元素</code></li>
<li>clear：清除所有元素<br><code>v5.clear();   // 将vector元素全部清除</code></li>
<li>insert：insert的重载有三个，定义如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">single <span class="title">element</span> <span class="params">(<span class="number">1</span>)</span>	iterator <span class="title">insert</span> <span class="params">(iterator position, <span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line">          fill (<span class="number">2</span>)	<span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(iterator position, size_type n, <span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line">         range (<span class="number">3</span>)	<span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;</span><br><span class="line">                        <span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(iterator position, InputIterator first, InputIterator last)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>insert操作可以在指定位置插入元素。在<strong>c++11</strong>中将定义中的 iterator修改成了const_iterator。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inserting into a vector</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (<span class="number">3</span>,<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line">  it = myvector.begin();</span><br><span class="line">  it = myvector.insert ( it , <span class="number">200</span> );</span><br><span class="line"></span><br><span class="line">  myvector.insert (it,<span class="number">2</span>,<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// "it" no longer valid, get a new one:</span></span><br><span class="line">  it = myvector.begin();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; anothervector (<span class="number">2</span>,<span class="number">400</span>);</span><br><span class="line">  myvector.insert (it+<span class="number">2</span>,anothervector.begin(),anothervector.end());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> myarray [] = &#123; <span class="number">501</span>,<span class="number">502</span>,<span class="number">503</span> &#125;;</span><br><span class="line">  myvector.insert (myvector.begin(), myarray, myarray+<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myvector contains:"</span>;</span><br><span class="line">  <span class="keyword">for</span> (it=myvector.begin(); it&lt;myvector.end(); it++)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><strong>emplace(c++11)</strong>：在指定位置插入一个新元素 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="function">iterator <span class="title">emplace</span> <span class="params">(const_iterator position, Args&amp;&amp;... args)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c++11 emplace</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_emplace</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v5(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v5.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        v5.at(i) = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it = v5.emplace(v5.begin()+<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">    v5.emplace(it, <span class="number">200</span>);</span><br><span class="line">    v5.emplace(v5.end(), <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"v5 contains: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: v5)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; <span class="string">' '</span> &lt;&lt; x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="vector的重分配"><a href="#vector的重分配" class="headerlink" title="vector的重分配"></a>vector的重分配</h3><p>当存储的数据超过分配的空间时vector会重新分配一块内存块，但这样的分配是很耗时的，在重新分配空间时它会做这样的动作：<br><img src="http://7xsc1o.com1.z0.glb.clouddn.com/STLvector%E7%9A%84%E9%87%8D%E5%88%86%E9%85%8D.png" alt="vector的重分配"><br>如果vector保存的数据量很大时，这样的操作一定会导致糟糕的性能（这也是vector 被设计成比较容易拷贝的值类型的原因）。所以说vector不是在什么情况下性能都好，只有在预先知道它大小的情况下vector 的性能才是最优的。</p>
<h3 id="vector的特点"><a href="#vector的特点" class="headerlink" title="vector的特点"></a>vector的特点</h3><ol>
<li>指定一块如同数组一样的连续存储，但空间可以动态扩展。即它可以像数组一样操作，并且可以进行动态操作。通常体现在push_back() pop_back() 。</li>
<li>随机访问方便，它像数组一样被访问，即支持[ ] 操作符和vector.at()</li>
<li>节省空间，因为它是连续存储，在存储数据的区域都是没有被浪费的，但是要明确一点vector 大多情况下并不是满存的，在未存储的区域实际是浪费的。</li>
<li>在内部进行插入、删除操作效率非常低，这样的操作基本上是被禁止的。Vector被设计成只能在后端进行追加和删除操作，其原因是vector 内部的实现是按照顺序表的原理。</li>
<li>只能在vector 的最后进行push 和pop ，不能在vector 的头进行push 和pop 。</li>
<li>当动态添加的数据超过vector默认分配的大小时要进行内存的重新分配、拷贝与释放，这个操作非常消耗性能。 所以要vector达到最优的性能，最好在创建vector时就指定其空间大小。</li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="http://www.cplusplus.com/" target="_blank" rel="external">C++ Reference</a><br>[2] <a href="http://zh.wikipedia.org/wiki/%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93" target="_blank" rel="external">Wiki：标准模板库</a> </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UNIX进程环境 （一）]]></title>
      <url>http://yoursite.com/2016/06/04/UNIX%E8%BF%9B%E7%A8%8B%E7%8E%AF%E5%A2%83%20%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>当执行程序时，其mai函数是如何被调用的，命令行参数是如何传送给执行程序的；典型的存储器布局是什么样式；如何分配另外的存储空间；进程如何使用环境变量；进程终止的不同方式等。另外，还将说明函数以及它们与栈的交互作用。<br><a id="more"></a></p>
<h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>C程序总是从main函数开始执行。main函数的原型是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main(int a rg c, char *a rg v[ ] ) ;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>内核启动C程序时，先调用一个特殊的例程，可执行程序文件将此起动例程指定为程序的起始地址。启动例程从内核里取命令行参数和环境变量值，然后为调用main函数作好安排。</p>
</blockquote>
<h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><p>有五种方式使进程终止：</p>
<ol>
<li>正常终止：<ul>
<li>从main函数返回</li>
<li>调用exit</li>
<li>调用_exit</li>
</ul>
</li>
<li>异常终止<ul>
<li>调用abort</li>
<li>由一个信号终止</li>
</ul>
</li>
</ol>
<h4 id="exit与-exit"><a href="#exit与-exit" class="headerlink" title="exit与_exit"></a>exit与_exit</h4><p>_exit属于系统调用，exit先进行一些清除处理，在调用_exit函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span> </span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> _exit (<span class="keyword">int</span> status) ;</span><br></pre></td></tr></table></figure></p>
<p>调用exit和_exit结束后进程将返回状态码（status），如果未指定状态码或使用了无返回值类型的return语句，进程返回的状态码将是未定的。如下一段程序，它的返回值是未定的：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">main ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="atexit函数"><a href="#atexit函数" class="headerlink" title="atexit函数"></a>atexit函数</h4><p>atexit函数可以注册在程序结束后的处理函数（最多32个），这些函数被称为终止处理函数（exit handle），当执行exit时exit将调用这些函数。atexit函数的定义：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int atexit(void (*function)(void));</span><br></pre></td></tr></table></figure></p>
<p>当注册多个终止处理函数时，是按照栈的方式来执行函数（后进先出），程序将按照我们来注册2个处理函数，当程序结束时打印 “bye2\n” 和 “I am exited\n”：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">////exit(0)是c库函数 =  _exit(0); //系统调用</span></span><br><span class="line"><span class="comment">//\n能启动刷新缓冲区的作用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bye1</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">true<span class="built_in">printf</span>(<span class="string">"I am exited\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bye2</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">true<span class="built_in">printf</span>(<span class="string">"bye2\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">trueatexit(bye1);</span><br><span class="line">trueatexit(bye2);</span><br><span class="line">true</span><br><span class="line">true<span class="built_in">printf</span>(<span class="string">"hello....\n"</span>);</span><br><span class="line">true<span class="comment">//abort();</span></span><br><span class="line">true</span><br><span class="line">truesleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">true<span class="comment">//exit(0); //是c库函数 =======其他操作。。。。在调用_exit</span></span><br><span class="line">true<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>在一个标准的main函数<code>int main(int argc, char *argv[])</code>，argc表示参数个数，<br>argv存放了参数，其中<code>argv[0]</code>存放的是程序文件名。输入的参数在执行程序时指定：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./echoarg arg1 TEST foo</span><br><span class="line">argv[0]: ./echoarg</span><br><span class="line">argv[1]: arg1</span><br><span class="line">argv[2]: TEST</span><br><span class="line">argv[3]: foo</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****************************************************</span><br><span class="line">true&gt; File Name: echo.c</span><br><span class="line">true&gt; Author: </span><br><span class="line">true&gt; Mail: </span><br><span class="line"> *****************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"argc=%d, argv=%s\n"</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="C程序的存储布局空间"><a href="#C程序的存储布局空间" class="headerlink" title="C程序的存储布局空间"></a>C程序的存储布局空间</h3><p>C程序由下列几部分组成：</p>
<table>
<thead>
<tr>
<th>type</th>
<th>information</th>
</tr>
</thead>
<tbody>
<tr>
<td>正文段</td>
<td>这是由C P U执行的机器指令部分</td>
</tr>
<tr>
<td>初始化数据段</td>
<td>通常将此段称为数据段，它包含了程序中需赋初值的变量。</td>
</tr>
<tr>
<td>非初始化数据段</td>
<td>通常将此段称为b s s段</td>
</tr>
<tr>
<td>栈</td>
<td>自动变量以及每次函数调用时所需保存的信息都存放在此段中。</td>
</tr>
<tr>
<td>堆</td>
<td>通常在堆中进行动态存储分配。</td>
</tr>
</tbody>
</table>
<p>通过 size（man size)命令可以查看这些信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ size /bin/sh</span><br><span class="line">   text	   data	    bss	    dec	    hex	filename</span><br><span class="line"> 107101	   2744	  10196	 120041	  1d4e9	/bin/sh</span><br></pre></td></tr></table></figure></p>
<p>第4和第5列是分别以十进制和十六进制表示的总长度。<br>以下是常见的C程序的存储布局空间图：<br><img src="http://7xsc1o.com1.z0.glb.clouddn.com/uninx/linux%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8BC%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AD%98%E5%82%A8%E5%B8%83%E5%B1%80%E7%A9%BA%E9%97%B4.PNG" alt="enter description here"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="">Uninx环境高级编程</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[位运算]]></title>
      <url>http://yoursite.com/2016/05/24/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      <content type="html"><![CDATA[<p>二进制是计算技术中广泛采用的一种数制。二进制数据是用0和1两个数码来表示的数。它的基数为2，进位规则是“逢二进一”，借位规则是“借一当二”，由18世纪德国数理哲学大师莱布尼兹发现。当前的计算机系统使用的基本上是二进制系统，数据在计算机中主要是以补码的形式存储的。<br><a id="more"></a></p>
<h2 id="二进制的操作"><a href="#二进制的操作" class="headerlink" title="二进制的操作"></a>二进制的操作</h2><h3 id="1-位移"><a href="#1-位移" class="headerlink" title="1 位移"></a>1 位移</h3><p>一个 <code>unsigned char</code> 由一个字节构成。<br><strong>左移运算</strong>：<code>X&lt;&lt;Y</code>：</p>
<blockquote>
<p>将x左移y位，将x最左边的y位丢弃，在右边补y个0。</p>
</blockquote>
<p><strong>右移运算</strong>：<code>X&gt;&gt;Y</code>：</p>
<blockquote>
<p>将x右移y位，这需要区分x是有符号数还是无符号数。在x是无符号数时，只需将x的最右边的y位丢弃，在左边补上y个0。在x是有符号数时，又分为x是正数还是负数。正数时，同无符号数的处理相同；负数时，将将x的最右边的y位丢弃，在左边补上y个1。</p>
</blockquote>
<p><strong>左移1位</strong>：相当于 乘2<br><strong>右移1位</strong>：相当于 除2<br>要注意可能 溢出 的情况</p>
<p>优点：移位运算 比 乘除运算 速度更快 更省CPU<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">// 0001 0011</span></span><br><span class="line">    <span class="comment">// 1    3</span></span><br><span class="line">    <span class="comment">// 0x13</span></span><br><span class="line">    <span class="comment">// 16 * 1 + 2 + 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> a = <span class="number">0x13</span>; <span class="comment">// 0001 0011</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> b = a &lt;&lt; <span class="number">2</span>; <span class="comment">// 0100 1100</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> c = b &gt;&gt; <span class="number">2</span>; <span class="comment">// 0001 0011</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-按位与运算符-amp"><a href="#2-按位与运算符-amp" class="headerlink" title="2 按位与运算符 &amp;"></a>2 按位与运算符 &amp;</h3><blockquote>
<p>按位与运算符”&amp;”是双目运算符。 其功能是参与运算的两数各对应的二进位相与。只有对应的两个二进位均为1时，结果位才为1，否则为0。参与运算的数以补码方式出现。</p>
</blockquote>
<p>例如：<code>9&amp;5</code>可写算式如下： <code>00001001 &amp; 00000101 = 00000001</code>可见<code>9&amp;5=1</code>。 按位与运算<strong>通常用来对某些位清0或保留某些位</strong>。例如把a 的高八位清 0 ， 保留低八位， 可作 <code>a&amp;255</code> 运算 ( 255 的二进制数为11111111)。<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span>&amp; <span class="number">1</span> = <span class="number">1</span>， <span class="number">1</span> | <span class="number">1</span> = <span class="number">1</span>， <span class="number">1</span> ^ <span class="number">1</span> = <span class="number">0</span></span><br><span class="line"><span class="symbol">1 </span>&amp; <span class="number">0</span> = <span class="number">0</span>， <span class="number">1</span> | <span class="number">0</span> = <span class="number">1</span>， <span class="number">1</span> ^ <span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="symbol">0 </span>&amp; <span class="number">1</span> = <span class="number">0</span>， <span class="number">0</span> | <span class="number">1</span> = <span class="number">1</span>， <span class="number">0</span> ^ <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="symbol">0 </span>&amp; <span class="number">0</span> = <span class="number">0</span>， <span class="number">0</span> | <span class="number">0</span> = <span class="number">0</span>， <span class="number">0</span> ^ <span class="number">0</span> = <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    inta=<span class="number">9</span>,b=<span class="number">5</span>,c;</span><br><span class="line">    c=a&amp;b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a=%d\nb=%d\nc=%d\n"</span>,a,b,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-按位或运算符"><a href="#3-按位或运算符" class="headerlink" title="3 按位或运算符 |"></a>3 按位或运算符 |</h3><blockquote>
<p>按位或运算符“|”是双目运算符。其功能是参与运算的两数各对应的二进位相或。只要对应的二个二进位有一个为1时，结果位就为1。</p>
</blockquote>
<p><strong>按位或运算常用来对一个数据的某些位定值为1</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">240</span> <span class="comment">// 1111 0000</span></span><br><span class="line">    <span class="keyword">int</span> pnum = <span class="number">15</span> <span class="comment">// 0000 1111</span></span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>; <span class="comment">// 0000 0000</span></span><br><span class="line">    </span><br><span class="line">    temp = num | pnum <span class="comment">//1111 1111 (255)</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, temp); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-异或运算符"><a href="#4-异或运算符" class="headerlink" title="4 异或运算符 ^"></a>4 异或运算符 ^</h3><blockquote>
<p>　异或运算符 <code>^</code> 也称 <code>XOR</code> 运算符。它的规则是若参加运算的两个二进位同号，则结果为0，异号则为1。即 <code>0^0=0; 0^1=1; 1^0=1;1^1=0</code>。</p>
</blockquote>
<ol>
<li><p>使特定位翻转<br>假设有 <code>01111010</code>，想使其低4 位翻转，即 1 变为 0，0 变为 1，可以将它与 <code>00001111</code>进行 <code>^</code> 运算</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01111010</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">00001111 </span>^</span><br><span class="line"></span><br><span class="line"><span class="number">01110101</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>与 0 相 ^ 保留原值</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00001010</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">00000000 </span>^</span><br><span class="line"></span><br><span class="line"><span class="number">00001010</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>交换两个值，不用临时变量<br>假如 a = 3, b = 4。想将 a 和 b的值互换，可以用以下赋值语句实现：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">a</span> = a ^ b;</span><br><span class="line"></span><br><span class="line"><span class="attr">b</span> = b ^ a;</span><br><span class="line"></span><br><span class="line"><span class="attr">a</span> = a ^ b;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="5-按位取反"><a href="#5-按位取反" class="headerlink" title="5 按位取反 ~"></a>5 按位取反 ~</h3><blockquote>
<p>  按位取反运算是单目运算，用来求一个位串信息按位的反，即哪些为0的位，结果是1，而哪些为1的位，结果是0。例如, <code>~7</code>的结果为<code>0xfff8</code>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">int</span> a=<span class="number">077</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%d"</span>,~a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="6-计算技巧"><a href="#6-计算技巧" class="headerlink" title="6 计算技巧"></a>6 计算技巧</h3><h4 id="1-检查state的第pos位是否为1"><a href="#1-检查state的第pos位是否为1" class="headerlink" title="1 检查state的第pos位是否为1"></a>1 检查state的第pos位是否为1</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitCheck</span><span class="params">(<span class="keyword">int</span> state, <span class="keyword">int</span> pos)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state &amp; <span class="number">1</span>&lt;&lt; pos - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-将state的第pos位的值设为1"><a href="#2-将state的第pos位的值设为1" class="headerlink" title="2 将state的第pos位的值设为1"></a>2 将state的第pos位的值设为1</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitAdd</span><span class="params">(<span class="keyword">int</span> state, <span class="keyword">int</span> pos)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state | (<span class="number">1</span> &lt;&lt; (pos - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-将state的第pos位的值设为0"><a href="#3-将state的第pos位的值设为0" class="headerlink" title="3 将state的第pos位的值设为0"></a>3 将state的第pos位的值设为0</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitDel</span><span class="params">(<span class="keyword">int</span> state, <span class="keyword">int</span> pos)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state &amp; (~(<span class="number">1</span> &lt;&lt; (pos - <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-计算一个数的二进制中1的个数"><a href="#4-计算一个数的二进制中1的个数" class="headerlink" title="4 计算一个数的二进制中1的个数"></a>4 计算一个数的二进制中1的个数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countof1</span><span class="params">(<span class="keyword">int</span> num)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flag = <span class="number">1</span> <span class="comment">//0x01  0000 0001</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &amp; flag)</span><br><span class="line">        &#123;</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = flag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-判断一个数是否是2的n次方"><a href="#5-判断一个数是否是2的n次方" class="headerlink" title="5 判断一个数是否是2的n次方"></a>5 判断一个数是否是2的n次方</h4><p>一个数是2的n次方，则这个数的最高位是1，其余位为0。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span><br><span class="line">    判断一个数是否为2的n次方（一个数为2的n次方，则最高位为1，其余位为0） </span><br><span class="line">*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is2Power</span><span class="params">(<span class="keyword">int</span> num)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;  </span><br><span class="line">  </span><br><span class="line">    num = num &amp; (num - <span class="number">1</span>); <span class="comment">//计算num和num - 1的与的结果  </span></span><br><span class="line">    <span class="keyword">if</span>(num) <span class="comment">//如果结果为0，则不是2的n次方  </span></span><br><span class="line">    &#123;  </span><br><span class="line">        flag = <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> flag;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="6-整数n经过多少步可以变为整数m"><a href="#6-整数n经过多少步可以变为整数m" class="headerlink" title="6 整数n经过多少步可以变为整数m"></a>6 整数n经过多少步可以变为整数m</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span><br><span class="line">    求解n变化为m，需要进行的操作步数 </span><br><span class="line">*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countChange</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    n = n ^ m; <span class="comment">//求n和m的异或,再计算结果中1的个数  </span></span><br><span class="line">    <span class="keyword">return</span> countOf1_2(n);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="7-获得最大的int值"><a href="#7-获得最大的int值" class="headerlink" title="7 获得最大的int值"></a>7 获得最大的int值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span><br><span class="line">    获取最大的int </span><br><span class="line">    得到结果：2147483647 </span><br><span class="line">*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxInt</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-获得最小的int值"><a href="#8-获得最小的int值" class="headerlink" title="8 获得最小的int值"></a>8 获得最小的int值</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span><br><span class="line">    求最小int </span><br><span class="line">    得到结果：-2147483648 </span><br><span class="line">*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMinInt</span><span class="params">()</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9-判断一个数的奇偶性"><a href="#9-判断一个数的奇偶性" class="headerlink" title="9 判断一个数的奇偶性"></a>9 判断一个数的奇偶性</h4><p>判断奇偶性，实质是判断最后一位是否是1.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span><br><span class="line">    判断一个数的奇偶性.返回1，为奇数;返回0，为偶数 </span><br><span class="line">*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isOdd</span><span class="params">(<span class="keyword">int</span> num)</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> num &amp; <span class="number">1</span> == <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="10-求一个数的绝对值"><a href="#10-求一个数的绝对值" class="headerlink" title="10 求一个数的绝对值"></a>10 求一个数的绝对值</h4><p>下面的方法实现的基础是将n右移31位，可以获得n的符号。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span><br><span class="line">    取绝对值 </span><br><span class="line">    n右移31位，可以获得n的符号。若n为正数，得到0；若n为负数，得到 -1 </span><br><span class="line">     </span><br><span class="line">*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myAbs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> (n ^ n &gt;&gt; <span class="number">31</span>) - (n &gt;&gt; <span class="number">31</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="11-求两个数的平均值"><a href="#11-求两个数的平均值" class="headerlink" title="11 求两个数的平均值"></a>11 求两个数的平均值</h4><p>第一种方法较为普遍且简单，不多说了。第二种方法，需要知道的是，<code>( m ^ n ) &gt;&gt; 1</code>得到的结果是m和n其中一个数的有些位为1的值的一半，<code>m &amp; n</code>得到的结果是m 和n都为1的那些位，两个结果相加得到m和n的平均数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span><br><span class="line">    求m和n的平均数 </span><br><span class="line">*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAverage</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> (m + n) &gt;&gt; <span class="number">1</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/* </span><br><span class="line">    求m和n的平均数 </span><br><span class="line">    (m ^ n) &gt;&gt; 1 -&gt; 获得m和n两个数中一个数的某些位为1的一半 </span><br><span class="line">    m &amp; n -&gt; 获得m和n两个数中都为1的某些位 </span><br><span class="line">*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getAverage_2</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> ((m ^ n) &gt;&gt; <span class="number">1</span>) + (m &amp; n);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[STL学习（一）简介]]></title>
      <url>http://yoursite.com/2016/05/24/STL%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p><strong>STL（Standard TemplateLibrary）</strong>，即标准模板库，是一个具有工业强度的，高效的C++程序库。它被容纳于C++标准程序库（C++ Standard Library）中，是ANSI/ISOC++标准中最新的也是极具革命性的一部分。该库包含了诸多在计算机科学领域里所常用的基本数据结构和基本算法。为广大C++程序员们提供了一个可扩展的应用框架，高度体现了软件的可复用性。<br><a id="more"></a></p>
<h3 id="STL历史"><a href="#STL历史" class="headerlink" title="STL历史"></a>STL历史</h3><p><strong><em>STL = Standard Template Library</em></strong>，标准模板库，惠普实验室开发的一系列软件的统称。它是由<strong>Alexander Stepanov、Meng Lee</strong>和<strong>David R Musser</strong>在惠普实验室工作时所开发出来的。从根本上说，STL是一些“容器”的集合，这些“容器”有list,vector,set,map等，STL也是算法和其他一些组件的集合。这里的“容器”和算法的集合指的是世界上很多聪明人很多年的杰作。STL的目的是<strong>标准化组件</strong>，这样就不用重新开发，可以使用现成的组件。STL现在是C++的一部分，因此不用额外安装什么。<br>STL运用模板技术把数据结构与算法分离，再用迭代器将两者粘结在一起。<br>STL的组成主要有六个部分:</p>
<ol>
<li>容器</li>
<li>算法</li>
<li>迭代器</li>
<li>函数对象</li>
<li>适配器</li>
<li>内存分配器</li>
</ol>
<p>六者间的关系如下图（来自侯姐《STL源码剖析》一书 p6）：<br><img src="http://7xsc1o.com1.z0.glb.clouddn.com/c/c++stl.jpg" alt="STL关系图"></p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>STL的容器可以分为两大类，顺序性容器和关联性容器。<br>顺序性容器包括：</p>
<table>
<thead>
<tr>
<th>容器</th>
<th>特性</th>
</tr>
</thead>
<tbody>
<tr>
<td>vector</td>
<td>从后面快速的插入与删除，直接访问任何元素</td>
</tr>
<tr>
<td>deque</td>
<td>从前面或后面快速的插入与删除，直接访问任何元素</td>
</tr>
<tr>
<td>list</td>
<td>双链表，从任何地方快速插入与删除</td>
</tr>
</tbody>
</table>
<p>关联性容器包括：</p>
<table>
<thead>
<tr>
<th>容器</th>
<th>特性</th>
</tr>
</thead>
<tbody>
<tr>
<td>set</td>
<td>快速查找，不允许重复值</td>
</tr>
<tr>
<td>multiset</td>
<td>快速查找，允许重复值</td>
</tr>
<tr>
<td>map</td>
<td>一对多映射，基于关键字快速查找，不允许重复值</td>
</tr>
<tr>
<td>multimap</td>
<td>一对多映射，基于关键字快速查找，允许重复值</td>
</tr>
</tbody>
</table>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>STL</strong>供包括了近几百个算法，也都是计算机科学中的算法。比如算法for_each将为指定序列中的每一个元素调用指定的函数，<strong>stable_sort</strong>以你所指定的规则对序列进行稳定性排序等等。这样一来，只要我们熟悉了<strong>STL</strong>之后，许多代码可以被大大的化简，只需要通过调用一两个算法模板，就可以完成所需要的功能并大大地提升效率。<br>算法部分主要由头文件<code>&lt;algorithm&gt;</code>，<code>&lt;numeric&gt;</code>和<code>&lt;functional&gt;</code>组成。<algorithm>是所有STL头文件中最大的一个（尽管它很好理解），它是由一大堆模版函数组成的，可以认为每个函数在很大程度上都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。<code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。<code>&lt;functional&gt;</code>中则定义了一些模板类，用以声明函数对象。</algorithm></p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器在STL中用来将算法和容器联系起来，起着一种黏和剂的作用。几乎STL提供的所有算法都是通过迭代器存取元素序列进行工作的，每一个容器都定义了其本身所专有的迭代器，用以存取容器中的元素。<br>迭代器部分主要由头文件<code>&lt;utility&gt;</code>,<code>&lt;iterator&gt;</code>和<code>&lt;memory&gt;</code>组成。<code>&lt;utility&gt;</code>是一个很小的头文件，它包括了贯穿使用在STL中的几个模板的声明，<code>&lt;iterator&gt;</code>中提供了迭代器使用的许多方法，而对于<code>&lt;memory&gt;</code>的描述则十分的困难，它以不同寻常的方式为容器中的元素分配存储空间，同时也为某些算法执行期间产生的临时对象提供机制,<code>&lt;memory&gt;</code>中的主要部分是模板类<code>allocator</code>，它负责产生所有容器中的默认分配器。</p>
<h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><p>函数对象的行为类似函数，但可作为算法的某种策略（policy）。从实现的角度看，函数对象是一种重载了operator()（函数调用操作符）的class或class template。</p>
<h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><p>适配器是一种用来修饰容器或函数对象或迭代器的东西。例如，STL 提供    <code>queue</code>和<code>stack</code>，虽然他们看似容器，但其实只能算是一种容器适配器，因为他们的底层实现完全借助于deque，所有的操作都由底层deque提供。改变<code>functor/container/iterator</code>的接口者称为<code>functor/container/iterator adaptor</code>。</p>
<h3 id="内存分配器"><a href="#内存分配器" class="headerlink" title="内存分配器"></a>内存分配器</h3><p>负责空间配置与管理，本质是实现动态空间配置、空间管理、空间释放的一系列class template。它是容器的底层接口，实际使用STL的用户是看不到Allocation的。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="http://baike.baidu.com/subview/332356/10428592.htm" target="_blank" rel="external">百度百科：STL</a><br>[2] <a href="http://zh.wikipedia.org/wiki/%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93" target="_blank" rel="external">Wiki：标准模板库</a> </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python   批量下载图片]]></title>
      <url>http://yoursite.com/2016/04/13/python-%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87/</url>
      <content type="html"><![CDATA[<p>首先我们先分析这个程序，这个程序的功能从网页批量下载图片，既然是网页下载，无非有这三个步骤：</p>
<ol>
<li>先得到网页。得到网页，以便程序分析网页中的图片连接。</li>
<li>解析网页。分析网页，从中取出所有图片连接。</li>
<li>下载。通过得到的图片连接下载图片。</li>
</ol>
<p>分析完成后我们开始编写程序：<br><a id="more"></a></p>
<h4 id="先得到网页"><a href="#先得到网页" class="headerlink" title="先得到网页"></a>先得到网页</h4><p>python自带<code>urllib</code>库，利用这个库我们可以轻松的得到网页。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line">html = urllib.urlopen(<span class="string">"https://mm.taobao.com/1832304329.htm"</span>).read()</span><br></pre></td></tr></table></figure></p>
<p>这里有个要注意的地方:<code>编码问题</code> 我下的这个网页是<code>GBK</code>编码，所以要进行转换：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">html = html.decode(<span class="string">"GBK"</span>) <span class="comment"># decode 编码转换</span></span><br></pre></td></tr></table></figure></p>
<h4 id="解析网页"><a href="#解析网页" class="headerlink" title="解析网页"></a>解析网页</h4><p>接下来就是解析页面了，通过正则表达式可以很容易的到图片的连接，正则表达式在<code>re</code>库中我们导入它<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure></p>
<p>编译正则表达式:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg = re.compile(<span class="string">r'src="//(.*?)"/&gt;'</span>) <span class="comment"># 正则表达式 (编译正则表达式）</span></span><br></pre></td></tr></table></figure></p>
<p>解析网页：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imgurl = re.findall(reg, html)</span><br></pre></td></tr></table></figure></p>
<p>这样我们将所有的图片连接地址保存在了<code>imgurl</code>中了。</p>
<h4 id="下载网页中的图片并保存"><a href="#下载网页中的图片并保存" class="headerlink" title="下载网页中的图片并保存"></a>下载网页中的图片并保存</h4><p>利用切片得到图片的格式，将图片保存。图片连接格式：<code>img.alicdn.com/imgextra/i4/1832304329/TB1.9G9LVXXXXXeaXXXXXXXXXXX_!!0-tstar.jpg&quot;</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> imgurl:</span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"正在下载第%s张图片, 共%s张图片"</span> %(n, len(imgurl)) </span><br><span class="line">    urllib.urlretrieve(<span class="string">'http://%s'</span> %i, <span class="string">'%s.%s'</span> %(n, i[<span class="number">-3</span>:])) <span class="comment">#i[-3:]得到图片格式 并保存</span></span><br></pre></td></tr></table></figure>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p><img src="http://7xsc1o.com1.z0.glb.clouddn.com/pythonpython%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87.png" alt="python批量下载图片"></p>
<h4 id="完整源码"><a href="#完整源码" class="headerlink" title="完整源码"></a>完整源码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">html = urllib.urlopen(<span class="string">"https://mm.taobao.com/1832304329.htm"</span>).read()</span><br><span class="line">html = html.decode(<span class="string">"GBK"</span>) <span class="comment"># decode and encode 学习  编码转换</span></span><br><span class="line"></span><br><span class="line">reg = re.compile(<span class="string">r'src="//(.*?)"/&gt;'</span>) <span class="comment"># 正则表达式 (编译正则表达式）</span></span><br><span class="line"></span><br><span class="line">imgurl = re.findall(reg, html)</span><br><span class="line"></span><br><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> imgurl:</span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"正在下载第%s张图片, 共%s张图片"</span> %(n, len(imgurl))</span><br><span class="line">    urllib.urlretrieve(<span class="string">'http://%s'</span> %i, <span class="string">'%s.%s'</span> %(n, i[<span class="number">-3</span>:]))</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[安装libevent开发库]]></title>
      <url>http://yoursite.com/2016/03/28/%E5%AE%89%E8%A3%85libevent%E5%BC%80%E5%8F%91%E5%BA%93/</url>
      <content type="html"><![CDATA[<p>为了稳定性，我选 <code>2.0.21-stable</code> 版本。在安装中注意要以<code>root</code>用户身份运行。<br><a id="more"></a></p>
<h3 id="1-下载源码包"><a href="#1-下载源码包" class="headerlink" title="1.下载源码包"></a>1.下载源码包</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="javascript">https:<span class="comment">//codeload.github.com/nmathewson/Libevent/tar.gz/release-2.0.21-stable</span></span>`</span><br></pre></td></tr></table></figure>
<h3 id="2-解压"><a href="#2-解压" class="headerlink" title="2.解压"></a>2.解压</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tar</span> <span class="selector-tag">-zxvf</span> <span class="selector-tag">Libevent-release-2</span><span class="selector-class">.0</span><span class="selector-class">.21-stable</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure>
<h3 id="3-配置安装路径"><a href="#3-配置安装路径" class="headerlink" title="3.配置安装路径"></a>3.配置安装路径</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Libevent-release-2.0.21-stable/</span><br><span class="line">./configure -prefix=/usr</span><br></pre></td></tr></table></figure>
<h3 id="4-编译并安装"><a href="#4-编译并安装" class="headerlink" title="4.编译并安装"></a>4.编译并安装</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span></span><br><span class="line"><span class="built_in">make</span> install</span><br></pre></td></tr></table></figure>
<h3 id="5-测试libevent是否安装成功"><a href="#5-测试libevent是否安装成功" class="headerlink" title="5.测试libevent是否安装成功"></a>5.测试libevent是否安装成功</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#ls -al <span class="regexp">/usr/</span>lib | <span class="keyword">grep</span> libevent</span><br></pre></td></tr></table></figure>
<p><img src="http://7xsc1o.com1.z0.glb.clouddn.com/programerlibevent%E5%AE%89%E8%A3%85%E6%B5%8B%E8%AF%95.PNG" class="thumbnail"></p>
<h3 id="6-说明"><a href="#6-说明" class="headerlink" title="6.说明"></a>6.说明</h3><p>如果编译后的程序提示找不到libvent的so，则创建库的链接和缓存文件<code>ldconfig</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[开博——记录程序员的成长]]></title>
      <url>http://yoursite.com/2016/03/27/%E5%BC%80%E5%8D%9A%E2%80%94%E2%80%94%E8%AE%B0%E5%BD%95%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%88%90%E9%95%BF/</url>
      <content type="html"><![CDATA[<p>这是我开博的第一片博客，我久思冥想不知道该写些什么。人们对事情的开头总是寄托了自己美好的愿想，常言道“善始善终”，一个好的开头总是能给人看到希望，给人坚持走下去的动力。<br><a id="more"></a></p>
<p>人们眼中的程序员，往往是带着黑框眼镜、穿着蓝色牛仔、外加格子衬衫，整日埋头在电脑面前的，没有情感的‘机器’。只有程序员自己才能明白其实我们是有感情的，而且异常丰富。我们会为一个bug破口大骂，会为一个巧妙的算法惊呼，会为最终完成作品而感动流泪。程序员也是人，是充满感情的‘作家‘。</p>
<p>其实技术这条路，带来的不仅仅是技能上的提高，有时候更多的是给自己带来的成长，让自己更加稳重、成熟。越是在技术上钻研，越是发现机器下的世界和人们生活的世界是多么相似。人世间的纷纷扰扰在0和1的世界里同样存在，机器世界的制度规则在生活里同样上演。</p>
<p>以前自己的记录都写在本地上，虽然有过开博的想法，但总是因为各种各样的事情没有开成。可以说这次开博不容易。我希望在未来的日子了，将自己的技术领悟，人生随想都记录到这里，和大家一起学习，一起成长，共同见证一个程序员的岁月。</p>
]]></content>
    </entry>
    
  
  
</search>
